// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Simple end-to-end conformance tests.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=.js,ts_nocheck=false"
// @generated from file cel/expr/conformance/test/simple.proto (package cel.expr.conformance.test, syntax proto3)
/* eslint-disable */

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Decl } from "../../checked_pb.js";
import { ErrorSet, ExprValue, UnknownSet } from "../../eval_pb.js";
import { Value } from "../../value_pb.js";

/**
 * The format of a simple test file, expected to be stored in text format.
 * A file is the unit of granularity for selecting conformance tests,
 * so tests of optional features should be segregated into separate files.
 *
 * @generated from message cel.expr.conformance.test.SimpleTestFile
 */
export class SimpleTestFile extends Message<SimpleTestFile> {
  /**
   * Required.  The name of the file.  Should match the filename.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * A description of the file.
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * The contained sections.
   *
   * @generated from field: repeated cel.expr.conformance.test.SimpleTestSection section = 3;
   */
  section: SimpleTestSection[] = [];

  constructor(data?: PartialMessage<SimpleTestFile>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cel.expr.conformance.test.SimpleTestFile";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "section", kind: "message", T: SimpleTestSection, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SimpleTestFile {
    return new SimpleTestFile().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SimpleTestFile {
    return new SimpleTestFile().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SimpleTestFile {
    return new SimpleTestFile().fromJsonString(jsonString, options);
  }

  static equals(a: SimpleTestFile | PlainMessage<SimpleTestFile> | undefined, b: SimpleTestFile | PlainMessage<SimpleTestFile> | undefined): boolean {
    return proto3.util.equals(SimpleTestFile, a, b);
  }
}

/**
 * A collection of related SimpleTests.
 *
 * The section is the unit of organization within a test file, and should
 * guide where new tests are added.
 *
 * @generated from message cel.expr.conformance.test.SimpleTestSection
 */
export class SimpleTestSection extends Message<SimpleTestSection> {
  /**
   * Required.  The name of the section.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * A description of the section.
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * The contained tests.
   *
   * @generated from field: repeated cel.expr.conformance.test.SimpleTest test = 3;
   */
  test: SimpleTest[] = [];

  constructor(data?: PartialMessage<SimpleTestSection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cel.expr.conformance.test.SimpleTestSection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "test", kind: "message", T: SimpleTest, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SimpleTestSection {
    return new SimpleTestSection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SimpleTestSection {
    return new SimpleTestSection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SimpleTestSection {
    return new SimpleTestSection().fromJsonString(jsonString, options);
  }

  static equals(a: SimpleTestSection | PlainMessage<SimpleTestSection> | undefined, b: SimpleTestSection | PlainMessage<SimpleTestSection> | undefined): boolean {
    return proto3.util.equals(SimpleTestSection, a, b);
  }
}

/**
 * A test which should run the given CEL program through parsing,
 * optionally through checking, then evaluation, with the results
 * of the pipeline validated by the given result matcher.
 *
 * @generated from message cel.expr.conformance.test.SimpleTest
 */
export class SimpleTest extends Message<SimpleTest> {
  /**
   * Required.  The name of the test, which should be unique in the test file.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * A description of the test.
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * Required.  The text of the CEL expression.
   *
   * @generated from field: string expr = 3;
   */
  expr = "";

  /**
   * Disables all macro expansion in parsing.
   *
   * @generated from field: bool disable_macros = 4;
   */
  disableMacros = false;

  /**
   * Disables the check phase.
   *
   * @generated from field: bool disable_check = 5;
   */
  disableCheck = false;

  /**
   * The type environment to use for the check phase.
   *
   * @generated from field: repeated cel.expr.Decl type_env = 6;
   */
  typeEnv: Decl[] = [];

  /**
   * The container for name resolution.
   *
   * @generated from field: string container = 13;
   */
  container = "";

  /**
   * The locale to use for the evaluation phase.
   *
   * @generated from field: string locale = 14;
   */
  locale = "";

  /**
   * Variable bindings to use for the eval phase.
   *
   * @generated from field: map<string, cel.expr.ExprValue> bindings = 7;
   */
  bindings: { [key: string]: ExprValue } = {};

  /**
   * An unspecified result defaults to a matcher for the true boolean value.
   *
   * @generated from oneof cel.expr.conformance.test.SimpleTest.result_matcher
   */
  resultMatcher: {
    /**
     * A normal value, which must match the evaluation result exactly
     * via value equality semantics.  This coincides with proto equality,
     * except for:
     * *   maps are order-agnostic.
     * *   a floating point NaN should match any NaN.
     *
     * @generated from field: cel.expr.Value value = 8;
     */
    value: Value;
    case: "value";
  } | {
    /**
     * Matches error evaluation results.
     *
     * @generated from field: cel.expr.ErrorSet eval_error = 9;
     */
    value: ErrorSet;
    case: "evalError";
  } | {
    /**
     * Matches one of several error results.
     * (Using explicit message since oneof can't handle repeated.)
     *
     * @generated from field: cel.expr.conformance.test.ErrorSetMatcher any_eval_errors = 10;
     */
    value: ErrorSetMatcher;
    case: "anyEvalErrors";
  } | {
    /**
     * Matches unknown evaluation results.
     *
     * @generated from field: cel.expr.UnknownSet unknown = 11;
     */
    value: UnknownSet;
    case: "unknown";
  } | {
    /**
     * Matches one of several unknown results.
     * (Using explicit message since oneof can't handle repeated.)
     *
     * @generated from field: cel.expr.conformance.test.UnknownSetMatcher any_unknowns = 12;
     */
    value: UnknownSetMatcher;
    case: "anyUnknowns";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SimpleTest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cel.expr.conformance.test.SimpleTest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "expr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "disable_macros", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "disable_check", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "type_env", kind: "message", T: Decl, repeated: true },
    { no: 13, name: "container", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "locale", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "bindings", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: ExprValue} },
    { no: 8, name: "value", kind: "message", T: Value, oneof: "result_matcher" },
    { no: 9, name: "eval_error", kind: "message", T: ErrorSet, oneof: "result_matcher" },
    { no: 10, name: "any_eval_errors", kind: "message", T: ErrorSetMatcher, oneof: "result_matcher" },
    { no: 11, name: "unknown", kind: "message", T: UnknownSet, oneof: "result_matcher" },
    { no: 12, name: "any_unknowns", kind: "message", T: UnknownSetMatcher, oneof: "result_matcher" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SimpleTest {
    return new SimpleTest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SimpleTest {
    return new SimpleTest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SimpleTest {
    return new SimpleTest().fromJsonString(jsonString, options);
  }

  static equals(a: SimpleTest | PlainMessage<SimpleTest> | undefined, b: SimpleTest | PlainMessage<SimpleTest> | undefined): boolean {
    return proto3.util.equals(SimpleTest, a, b);
  }
}

/**
 * Matches error results from Eval.
 *
 * @generated from message cel.expr.conformance.test.ErrorSetMatcher
 */
export class ErrorSetMatcher extends Message<ErrorSetMatcher> {
  /**
   * Success if we match any of these sets.
   *
   * @generated from field: repeated cel.expr.ErrorSet errors = 1;
   */
  errors: ErrorSet[] = [];

  constructor(data?: PartialMessage<ErrorSetMatcher>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cel.expr.conformance.test.ErrorSetMatcher";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "errors", kind: "message", T: ErrorSet, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ErrorSetMatcher {
    return new ErrorSetMatcher().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ErrorSetMatcher {
    return new ErrorSetMatcher().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ErrorSetMatcher {
    return new ErrorSetMatcher().fromJsonString(jsonString, options);
  }

  static equals(a: ErrorSetMatcher | PlainMessage<ErrorSetMatcher> | undefined, b: ErrorSetMatcher | PlainMessage<ErrorSetMatcher> | undefined): boolean {
    return proto3.util.equals(ErrorSetMatcher, a, b);
  }
}

/**
 * Matches unknown results from Eval.
 *
 * @generated from message cel.expr.conformance.test.UnknownSetMatcher
 */
export class UnknownSetMatcher extends Message<UnknownSetMatcher> {
  /**
   * Success if we match any of these sets.
   *
   * @generated from field: repeated cel.expr.UnknownSet unknowns = 1;
   */
  unknowns: UnknownSet[] = [];

  constructor(data?: PartialMessage<UnknownSetMatcher>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cel.expr.conformance.test.UnknownSetMatcher";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "unknowns", kind: "message", T: UnknownSet, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnknownSetMatcher {
    return new UnknownSetMatcher().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnknownSetMatcher {
    return new UnknownSetMatcher().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnknownSetMatcher {
    return new UnknownSetMatcher().fromJsonString(jsonString, options);
  }

  static equals(a: UnknownSetMatcher | PlainMessage<UnknownSetMatcher> | undefined, b: UnknownSetMatcher | PlainMessage<UnknownSetMatcher> | undefined): boolean {
    return proto3.util.equals(UnknownSetMatcher, a, b);
  }
}

