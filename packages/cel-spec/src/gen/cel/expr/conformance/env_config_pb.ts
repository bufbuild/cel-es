// Copyright 2024-2025 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.2.5 with parameter "target=ts,import_extension=.js,ts_nocheck=false"
// @generated from file cel/expr/conformance/env_config.proto (package cel.expr.conformance, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Decl } from "../checked_pb.js";
import { file_cel_expr_checked } from "../checked_pb.js";
import type { FileDescriptorSet, Value } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_descriptor, file_google_protobuf_struct } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file cel/expr/conformance/env_config.proto.
 */
export const file_cel_expr_conformance_env_config: GenFile = /*@__PURE__*/
  fileDesc("CiVjZWwvZXhwci9jb25mb3JtYW5jZS9lbnZfY29uZmlnLnByb3RvEhRjZWwuZXhwci5jb25mb3JtYW5jZSKSBQoLRW52aXJvbm1lbnQSDAoEbmFtZRgBIAEoCRITCgtkZXNjcmlwdGlvbhgCIAEoCRIRCgljb250YWluZXIYAyABKAkSOQoHaW1wb3J0cxgEIAMoCzIoLmNlbC5leHByLmNvbmZvcm1hbmNlLkVudmlyb25tZW50LkltcG9ydBIzCgZzdGRsaWIYBSABKAsyIy5jZWwuZXhwci5jb25mb3JtYW5jZS5MaWJyYXJ5U3Vic2V0EjMKCmV4dGVuc2lvbnMYBiADKAsyHy5jZWwuZXhwci5jb25mb3JtYW5jZS5FeHRlbnNpb24SSwoQY29udGV4dF92YXJpYWJsZRgHIAEoCzIxLmNlbC5leHByLmNvbmZvcm1hbmNlLkVudmlyb25tZW50LkNvbnRleHRWYXJpYWJsZRIkCgxkZWNsYXJhdGlvbnMYCCADKAsyDi5jZWwuZXhwci5EZWNsEjMKCnZhbGlkYXRvcnMYCSADKAsyHy5jZWwuZXhwci5jb25mb3JtYW5jZS5WYWxpZGF0b3ISLwoIZmVhdHVyZXMYCiADKAsyHS5jZWwuZXhwci5jb25mb3JtYW5jZS5GZWF0dXJlEikKIWRpc2FibGVfc3RhbmRhcmRfY2VsX2RlY2xhcmF0aW9ucxgLIAEoCBJCChZtZXNzYWdlX3R5cGVfZXh0ZW5zaW9uGAwgASgLMiIuZ29vZ2xlLnByb3RvYnVmLkZpbGVEZXNjcmlwdG9yU2V0EiIKGmVuYWJsZV9tYWNyb19jYWxsX3RyYWNraW5nGA0gASgIGhYKBkltcG9ydBIMCgRuYW1lGAEgASgJGiQKD0NvbnRleHRWYXJpYWJsZRIRCgl0eXBlX25hbWUYASABKAkinQEKCVZhbGlkYXRvchIMCgRuYW1lGAEgASgJEjsKBmNvbmZpZxgCIAMoCzIrLmNlbC5leHByLmNvbmZvcm1hbmNlLlZhbGlkYXRvci5Db25maWdFbnRyeRpFCgtDb25maWdFbnRyeRILCgNrZXkYASABKAkSJQoFdmFsdWUYAiABKAsyFi5nb29nbGUucHJvdG9idWYuVmFsdWU6AjgBIigKB0ZlYXR1cmUSDAoEbmFtZRgBIAEoCRIPCgdlbmFibGVkGAIgASgIIioKCUV4dGVuc2lvbhIMCgRuYW1lGAEgASgJEg8KB3ZlcnNpb24YAiABKAkivwEKDUxpYnJhcnlTdWJzZXQSEAoIZGlzYWJsZWQYASABKAgSFgoOZGlzYWJsZV9tYWNyb3MYAiABKAgSFgoOaW5jbHVkZV9tYWNyb3MYAyADKAkSFgoOZXhjbHVkZV9tYWNyb3MYBCADKAkSKQoRaW5jbHVkZV9mdW5jdGlvbnMYBSADKAsyDi5jZWwuZXhwci5EZWNsEikKEWV4Y2x1ZGVfZnVuY3Rpb25zGAYgAygLMg4uY2VsLmV4cHIuRGVjbEJLChhjZWwuZGV2LmV4cHIuY29uZm9ybWFuY2VCEEVudmlyb25tZW50UHJvdG9QAVoYY2VsLmRldi9leHByL2NvbmZvcm1hbmNl+AEBYgZwcm90bzM", [file_cel_expr_checked, file_google_protobuf_struct, file_google_protobuf_descriptor]);

/**
 * Representation of a CEL Environment, defining what features and extensions
 * are available for conformance testing.
 *
 * @generated from message cel.expr.conformance.Environment
 */
export type Environment = Message<"cel.expr.conformance.Environment"> & {
  /**
   * Name of the environment
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Description for the current environment
   *
   * @generated from field: string description = 2;
   */
  description: string;

  /**
   * Sets the namespace (container) for the expression.
   * This is used to simplify resolution.
   * For example with container
   *   `google.rpc.context`
   *  an identifier of `google.rpc.context.AttributeContext` could be referred
   *  to simply as `AttributeContext` in the CEL expression.
   *
   * @generated from field: string container = 3;
   */
  container: string;

  /**
   * List of abbreviations to be added to the CEL environment
   *
   * @generated from field: repeated cel.expr.conformance.Environment.Import imports = 4;
   */
  imports: Environment_Import[];

  /**
   * Set of options to subset a subsettable library
   *
   * @generated from field: cel.expr.conformance.LibrarySubset stdlib = 5;
   */
  stdlib?: LibrarySubset;

  /**
   * List of extensions to enable in the CEL environment.
   *
   * @generated from field: repeated cel.expr.conformance.Extension extensions = 6;
   */
  extensions: Extension[];

  /**
   * If set, adds a context declaration from a proto message.
   *
   * Context messages have all of their top-level fields available as variables
   * in the type checker.
   *
   * @generated from field: cel.expr.conformance.Environment.ContextVariable context_variable = 7;
   */
  contextVariable?: Environment_ContextVariable;

  /**
   * List of declarations to be configured in the CEL environment.
   *
   * Note: The CEL environment can be configured with either the
   * context_variable or a set of ident_decls provided as part of declarations.
   * Providing both will result in an error.
   *
   * @generated from field: repeated cel.expr.Decl declarations = 8;
   */
  declarations: Decl[];

  /**
   * List of validators for validating the parsed ast.
   *
   * @generated from field: repeated cel.expr.conformance.Validator validators = 9;
   */
  validators: Validator[];

  /**
   * List of feature flags to be enabled or disabled.
   *
   * @generated from field: repeated cel.expr.conformance.Feature features = 10;
   */
  features: Feature[];

  /**
   * Disables including the declarations from the standard CEL environment.
   *
   * NOTE: Do not disable the standard CEL declarations unless you are aware of
   * the implications and have discussed your use case on cel-discuss@
   * or with the members of the cel-governance-team@
   *
   * Deprecated: Use LibrarySubset to disable standard cel declarations instead:
   *   stdlib = LibrarySubset{ disable: true }
   *
   * @generated from field: bool disable_standard_cel_declarations = 11;
   */
  disableStandardCelDeclarations: boolean;

  /**
   * If provided, uses the provided FileDescriptorSet to extend types available
   * the CEL expression. All "well-known" protobuf messages (google.protobuf.*)
   * are known to the CEL compiler, but all others must be provided for type
   * checking.
   *
   * @generated from field: google.protobuf.FileDescriptorSet message_type_extension = 12;
   */
  messageTypeExtension?: FileDescriptorSet;

  /**
   * When macro call tracking is enabled, the resulting SourceInfo in the
   * CheckedExpr will contain a collection of expressions representing the
   * function calls which were replaced by macros.
   *
   * Deprecated: Use Feature to enable macro call tracking
   *  Feature{ name: "cel.feature.macro_call_tracking", enabled: true }
   *
   * @generated from field: bool enable_macro_call_tracking = 13;
   */
  enableMacroCallTracking: boolean;
};

/**
 * Describes the message cel.expr.conformance.Environment.
 * Use `create(EnvironmentSchema)` to create a new message.
 */
export const EnvironmentSchema: GenMessage<Environment> = /*@__PURE__*/
  messageDesc(file_cel_expr_conformance_env_config, 0);

/**
 * Import represents a type name that will be abbreviated by its simple name
 * making it easier to reference simple type names from packages other than
 * the expression container.
 * For ex:
 *   Import{name: 'google.rpc.Status'}
 * The above import will ensure that `google.rpc.Status` is available by the
 * simple name `Status` within CEL expressions.
 *
 * @generated from message cel.expr.conformance.Environment.Import
 */
export type Environment_Import = Message<"cel.expr.conformance.Environment.Import"> & {
  /**
   * Qualified type name which will be abbreviated
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message cel.expr.conformance.Environment.Import.
 * Use `create(Environment_ImportSchema)` to create a new message.
 */
export const Environment_ImportSchema: GenMessage<Environment_Import> = /*@__PURE__*/
  messageDesc(file_cel_expr_conformance_env_config, 0, 0);

/**
 * ContextVariable represents a message type to be made available as a
 * context variable to the CEL environment.
 *
 * @generated from message cel.expr.conformance.Environment.ContextVariable
 */
export type Environment_ContextVariable = Message<"cel.expr.conformance.Environment.ContextVariable"> & {
  /**
   * Fully qualified type name of the context proto.
   *
   * @generated from field: string type_name = 1;
   */
  typeName: string;
};

/**
 * Describes the message cel.expr.conformance.Environment.ContextVariable.
 * Use `create(Environment_ContextVariableSchema)` to create a new message.
 */
export const Environment_ContextVariableSchema: GenMessage<Environment_ContextVariable> = /*@__PURE__*/
  messageDesc(file_cel_expr_conformance_env_config, 0, 1);

/**
 * Represents a named validator with an optional map-based configuration object.
 * Naming convention followed by validators:
 *   <domain>.validator.<validator_name>
 * For ex:
 *   `cel.validator.timestamp`
 *
 * Note: the map-keys must directly correspond to the internal representation of
 * the original validator, and should only use primitive scalar types as values
 * at this time.
 *
 * @generated from message cel.expr.conformance.Validator
 */
export type Validator = Message<"cel.expr.conformance.Validator"> & {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Additional configurations to be included as part of the validation
   *
   * @generated from field: map<string, google.protobuf.Value> config = 2;
   */
  config: { [key: string]: Value };
};

/**
 * Describes the message cel.expr.conformance.Validator.
 * Use `create(ValidatorSchema)` to create a new message.
 */
export const ValidatorSchema: GenMessage<Validator> = /*@__PURE__*/
  messageDesc(file_cel_expr_conformance_env_config, 1);

/**
 * Represents a named boolean feature flag supported by CEL.
 * Naming convention followed by features:
 *   <domain>.feature.<feature_name>
 * For ex:
 *   `cel.feature.cross_type_numeric_comparisons`
 *
 * @generated from message cel.expr.conformance.Feature
 */
export type Feature = Message<"cel.expr.conformance.Feature"> & {
  /**
   * Name of the feature flag.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * State of the feature flab.
   *
   * @generated from field: bool enabled = 2;
   */
  enabled: boolean;
};

/**
 * Describes the message cel.expr.conformance.Feature.
 * Use `create(FeatureSchema)` to create a new message.
 */
export const FeatureSchema: GenMessage<Feature> = /*@__PURE__*/
  messageDesc(file_cel_expr_conformance_env_config, 2);

/**
 * Extension represents a versioned extension library reference to enable in the
 * CEL environment.
 *
 * @generated from message cel.expr.conformance.Extension
 */
export type Extension = Message<"cel.expr.conformance.Extension"> & {
  /**
   * Name of the extension library.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Version of the extension library.
   *
   * @generated from field: string version = 2;
   */
  version: string;
};

/**
 * Describes the message cel.expr.conformance.Extension.
 * Use `create(ExtensionSchema)` to create a new message.
 */
export const ExtensionSchema: GenMessage<Extension> = /*@__PURE__*/
  messageDesc(file_cel_expr_conformance_env_config, 3);

/**
 * LibrarySubset indicates a subset of the macros and functions supported by a
 * subsettable library.
 *
 * @generated from message cel.expr.conformance.LibrarySubset
 */
export type LibrarySubset = Message<"cel.expr.conformance.LibrarySubset"> & {
  /**
   * Indicates whether the library has been disabled, typically only
   * used for default-enabled libraries like stdlib.
   *
   * @generated from field: bool disabled = 1;
   */
  disabled: boolean;

  /**
   * Disables macros for the given library.
   *
   * @generated from field: bool disable_macros = 2;
   */
  disableMacros: boolean;

  /**
   * Specifies a set of macro function names to include in the subset.
   *
   * @generated from field: repeated string include_macros = 3;
   */
  includeMacros: string[];

  /**
   * Specifies a set of macro function names to exclude from the subset.
   * Note: if IncludeMacros is non-empty, then ExcludeFunctions is ignored.
   *
   * @generated from field: repeated string exclude_macros = 4;
   */
  excludeMacros: string[];

  /**
   * Specifies a set of functions to include in the subset.
   *
   * Note: the overloads specified in the subset need only specify their ID.
   * Note: if IncludeFunctions is non-empty, then ExcludeFunctions is ignored.
   *
   * @generated from field: repeated cel.expr.Decl include_functions = 5;
   */
  includeFunctions: Decl[];

  /**
   * Specifies the set of functions to exclude from the subset.
   *
   * Note: the overloads specified in the subset need only specify their ID.
   *
   * @generated from field: repeated cel.expr.Decl exclude_functions = 6;
   */
  excludeFunctions: Decl[];
};

/**
 * Describes the message cel.expr.conformance.LibrarySubset.
 * Use `create(LibrarySubsetSchema)` to create a new message.
 */
export const LibrarySubsetSchema: GenMessage<LibrarySubset> = /*@__PURE__*/
  messageDesc(file_cel_expr_conformance_env_config, 4);

