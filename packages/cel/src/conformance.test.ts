// Copyright 2024-2025 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { describe } from "node:test";
import { createTestFilter, testSimpleTestFile } from "./testing.js";
import { getSimpleTestFiles } from "@bufbuild/cel-spec/testdata/simple.js";
import { getTestRegistry } from "@bufbuild/cel-spec/testdata/registry.js";

const files = getSimpleTestFiles();

const failures = createTestFilter([
  ["bindings_ext"],
  ["block_ext"],
  ["dynamic", "list", "literal"],
  ["dynamic", "list", "var"],
  ["dynamic", "list", "field_read_proto2"],
  ["dynamic", "list", "field_read_proto3"],
  ["dynamic", "value_list", "literal"],
  ["dynamic", "value_list", "var"],
  ["dynamic", "value_list", "field_read_proto2"],
  ["dynamic", "value_list", "field_read_proto3"],
  ["dynamic", "complex", "any_list_map"],
  ["encoders_ext", "encode", "hello"],
  ["encoders_ext", "decode", "hello"],
  ["encoders_ext", "decode", "hello_without_padding"],
  ["encoders_ext", "round_trip", "hello"],
  ["fields", "quoted_map_fields"],
  ["proto2", "empty_field", "nested_message"],
  ["proto2", "quoted_fields"],
  ["proto2", "extensions_get"],
  ["proto2", "extensions_has"],
  ["proto2_ext"],
  ["proto3", "empty_field", "nested_message"],
  ["proto3", "quoted_fields"],
  ["string_ext", "format", "scientific notation formatting clause"],
  ["string_ext", "format", "default precision for scientific notation"],
  ["string_ext", "format", "dyntype support for scientific notation"],
  [
    "string_ext",
    "format",
    "scientific notation formatting clause in a string variable",
  ],
  // Enums began as Ints but were changed to have types and reverted back again: https://github.com/google/cel-spec/pull/321
  ["enums", "strong_proto2", "literal_global"],
  ["enums", "strong_proto2", "literal_nested"],
  ["enums", "strong_proto2", "literal_zero"],
  ["enums", "strong_proto2", "type_global"],
  ["enums", "strong_proto2", "type_nested"],
  ["enums", "strong_proto2", "select_default"],
  ["enums", "strong_proto2", "field_type"],
  ["enums", "strong_proto2", "assign_standalone_int"],
  ["enums", "strong_proto2", "convert_int_inrange"],
  ["enums", "strong_proto2", "convert_int_big"],
  ["enums", "strong_proto2", "convert_int_neg"],
  ["enums", "strong_proto2", "convert_string"],
  ["enums", "strong_proto3", "literal_global"],
  ["enums", "strong_proto3", "literal_nested"],
  ["enums", "strong_proto3", "literal_zero"],
  ["enums", "strong_proto3", "type_global"],
  ["enums", "strong_proto3", "type_nested"],
  ["enums", "strong_proto3", "select_default"],
  ["enums", "strong_proto3", "field_type"],
  ["enums", "strong_proto3", "assign_standalone_int"],
  ["enums", "strong_proto3", "convert_int_inrange"],
  ["enums", "strong_proto3", "convert_int_big"],
  ["enums", "strong_proto3", "convert_int_neg"],
  ["enums", "strong_proto3", "convert_string"],
  ["enums", "strong_proto3", "select"],
  ["enums", "strong_proto3", "select_big"],
  ["enums", "strong_proto3", "select_neg"],
  ["enums", "strong_proto3", "assign_standalone_int_big"],
  ["enums", "strong_proto3", "assign_standalone_int_neg"],
  // Macros2 is not tested in both Java and Go implementations.
  ["macros2", "exists", "list_elem_all_true"],
  ["macros2", "exists", "list_elem_some_true"],
  ["macros2", "exists", "list_elem_none_true"],
  ["macros2", "exists", "list_elem_type_shortcircuit"],
  ["macros2", "exists", "list_elem_type_exhaustive"],
  ["macros2", "exists", "list_empty"],
  ["macros2", "exists", "map_key"],
  ["macros2", "exists", "not_map_key"],
  ["macros2", "exists", "map_key_type_shortcircuit"],
  ["macros2", "exists", "map_key_type_exhaustive"],
  ["macros2", "all", "list_elem_all_true"],
  ["macros2", "all", "list_elem_some_true"],
  ["macros2", "all", "list_elem_none_true"],
  ["macros2", "all", "list_elem_type_shortcircuit"],
  ["macros2", "all", "list_elem_type_exhaustive"],
  ["macros2", "all", "list_elem_error_shortcircuit"],
  ["macros2", "all", "list_empty"],
  ["macros2", "all", "map_key"],
  ["macros2", "existsOne", "list_empty"],
  ["macros2", "existsOne", "list_one_true"],
  ["macros2", "existsOne", "list_one_false"],
  ["macros2", "existsOne", "list_none"],
  ["macros2", "existsOne", "list_one"],
  ["macros2", "existsOne", "list_many"],
  ["macros2", "existsOne", "list_all"],
  ["macros2", "existsOne", "map_one"],
  ["macros2", "transformList", "empty"],
  ["macros2", "transformList", "empty_filter"],
  ["macros2", "transformList", "one"],
  ["macros2", "transformList", "one_filter"],
  ["macros2", "transformList", "many"],
  ["macros2", "transformList", "many_filter"],
  ["macros2", "transformMap", "empty"],
  ["macros2", "transformMap", "empty_filter"],
  ["macros2", "transformMap", "one"],
  ["macros2", "transformMap", "one_filter"],
  ["macros2", "transformMap", "many"],
  ["macros2", "transformMap", "many_filter"],
  // We don't have support for type-checking.
  ["type_deductions"],
  // Failing in Go and Java as well.
  [
    "fields",
    "qualified_identifier_resolution",
    "map_value_repeat_key_heterogeneous",
  ],
  // Math extension functions are not implemented
  ["math_ext", "greatest_int_result"],
  ["math_ext", "greatest_double_result"],
  ["math_ext", "greatest_uint_result"],
  ["math_ext", "least_int_result"],
  ["math_ext", "least_double_result"],
  ["math_ext", "least_uint_result"],
  ["math_ext", "ceil", "negative"],
  ["math_ext", "ceil", "positive"],
  ["math_ext", "floor", "negative"],
  ["math_ext", "floor", "positive"],
  ["math_ext", "round", "negative_down"],
  ["math_ext", "round", "negative_up"],
  ["math_ext", "round", "negative_mid"],
  ["math_ext", "round", "positive_down"],
  ["math_ext", "round", "positive_up"],
  ["math_ext", "round", "nan"],
  ["math_ext", "trunc", "negative"],
  ["math_ext", "trunc", "positive"],
  ["math_ext", "trunc", "nan"],
  ["math_ext", "abs", "uint"],
  ["math_ext", "abs", "positive_int"],
  ["math_ext", "abs", "negative_int"],
  ["math_ext", "abs", "positive_double"],
  ["math_ext", "abs", "negative_double"],
  ["math_ext", "sign", "positive_uint"],
  ["math_ext", "sign", "positive_int"],
  ["math_ext", "sign", "negative_int"],
  ["math_ext", "sign", "positive_double"],
  ["math_ext", "sign", "negative_double"],
  ["math_ext", "sign", "zero_int"],
  ["math_ext", "sign", "zero_uint"],
  ["math_ext", "sign", "zero_double"],
  ["math_ext", "isNaN", "true"],
  ["math_ext", "isNaN", "false"],
  ["math_ext", "isInf", "false"],
  ["math_ext", "isInf", "true"],
  ["math_ext", "isFinite", "true"],
  ["math_ext", "isFinite", "false_nan"],
  ["math_ext", "isFinite", "false_inf"],
  ["math_ext", "bit_and", "int_int_non_intersect"],
  ["math_ext", "bit_and", "int_int_intersect"],
  ["math_ext", "bit_and", "int_int_intersect_neg"],
  ["math_ext", "bit_and", "uint_uint_non_intersect"],
  ["math_ext", "bit_and", "uint_uint_intersect"],
  ["math_ext", "bit_or", "int_int_positive"],
  ["math_ext", "bit_or", "int_int_positive_negative"],
  ["math_ext", "bit_or", "uint_uint"],
  ["math_ext", "bit_xor", "int_int_positive"],
  ["math_ext", "bit_xor", "int_int_positive_negative"],
  ["math_ext", "bit_xor", "uint_uint"],
  ["math_ext", "bit_not", "int_zero"],
  ["math_ext", "bit_not", "uint_zero"],
  ["math_ext", "bit_not", "int_positive"],
  ["math_ext", "bit_not", "int_negative"],
  ["math_ext", "bit_not", "uint_positive"],
  ["math_ext", "bit_shift_left", "int"],
  ["math_ext", "bit_shift_left", "int_large_shift"],
  ["math_ext", "bit_shift_left", "int_negative_large_shift"],
  ["math_ext", "bit_shift_left", "uint"],
  ["math_ext", "bit_shift_left", "uint_large_shift"],
  ["math_ext", "bit_shift_right", "int"],
  ["math_ext", "bit_shift_right", "int_large_shift"],
  ["math_ext", "bit_shift_right", "int_negative"],
  ["math_ext", "bit_shift_right", "int_negative_large_shift"],
  ["math_ext", "bit_shift_right", "uint"],
  ["math_ext", "bit_shift_right", "uint_large_shift"],
  ["optionals", "optionals", "null"],
  ["optionals", "optionals", "null_non_zero_value"],
  ["optionals", "optionals", "none_or_none_or_value"],
  ["optionals", "optionals", "none_optMap_hasValue"],
  ["optionals", "optionals", "empty_map_optFlatMap_hasValue"],
  ["optionals", "optionals", "map_empty_submap_optFlatMap_hasValue"],
  ["optionals", "optionals", "map_null_entry_hasValue"],
  ["optionals", "optionals", "map_null_entry_no_such_key"],
  ["optionals", "optionals", "map_absent_key_absent_field_none"],
  ["optionals", "optionals", "map_present_key_invalid_field"],
  ["optionals", "optionals", "map_undefined_entry_hasValue"],
  ["optionals", "optionals", "map_submap_subkey_optFlatMap_value"],
  ["optionals", "optionals", "map_submap_optFlatMap_value"],
  [
    "optionals",
    "optionals",
    "map_optindex_optFlatMap_optional_ofNonZeroValue_hasValue",
  ],
  ["optionals", "optionals", "optional_of_optMap_value"],
  ["optionals", "optionals", "optional_ofNonZeroValue_or_optional_value"],
  ["optionals", "optionals", "ternary_optional_hasValue"],
  ["optionals", "optionals", "map_optindex_hasValue"],
  ["optionals", "optionals", "has_map_optindex"],
  ["optionals", "optionals", "has_map_optindex_field"],
  ["optionals", "optionals", "type"],
  ["optionals", "optionals", "optional_chaining_1"],
  ["optionals", "optionals", "optional_chaining_2"],
  ["optionals", "optionals", "optional_chaining_3"],
  ["optionals", "optionals", "optional_chaining_4"],
  ["optionals", "optionals", "optional_chaining_5"],
  ["optionals", "optionals", "optional_chaining_6"],
  ["optionals", "optionals", "optional_chaining_7"],
  ["optionals", "optionals", "optional_chaining_8"],
  ["optionals", "optionals", "optional_chaining_9"],
  ["optionals", "optionals", "optional_chaining_11"],
  ["optionals", "optionals", "optional_chaining_12"],
  ["optionals", "optionals", "optional_chaining_13"],
  ["optionals", "optionals", "optional_chaining_14"],
  ["optionals", "optionals", "optional_chaining_15"],
  ["optionals", "optionals", "optional_chaining_16"],
  [
    "optionals",
    "optionals",
    "has_optional_ofNonZeroValue_struct_optional_ofNonZeroValue_map_optindex_field",
  ],
  [
    "optionals",
    "optionals",
    "optional_ofNonZeroValue_struct_optional_ofNonZeroValue_map_optindex_field",
  ],
  ["optionals", "optionals", "struct_map_optindex_field"],
  [
    "optionals",
    "optionals",
    "struct_optional_ofNonZeroValue_map_optindex_field",
  ],
  ["optionals", "optionals", "struct_map_optindex_field_nested"],
  ["optionals", "optionals", "struct_list_optindex_field"],
  ["optionals", "optionals", "optional_empty_map_optindex_hasValue"],
  ["optionals", "optionals", "empty_struct_optindex_hasValue"],
  ["optionals", "optionals", "optional_empty_struct_optindex_hasValue"],
  ["optionals", "optionals", "optional_none_optselect_hasValue"],
  ["optionals", "optionals", "struct_optindex_value"],
  ["optionals", "optionals", "optional_struct_optindex_value"],
  ["optionals", "optionals", "optional_struct_optindex_index_value"],
  ["optionals", "optionals", "empty_list_optindex_hasValue"],
  ["optionals", "optionals", "optional_empty_list_optindex_hasValue"],
  ["optionals", "optionals", "optional_none_optindex_hasValue"],
  ["optionals", "optionals", "list_optindex_value"],
  ["optionals", "optionals", "optional_list_optindex_value"],
  ["optionals", "optionals", "map_key_mixed_type_optindex_value"],
  ["optionals", "optionals", "map_key_mixed_numbers_double_key_optindex_value"],
  ["optionals", "optionals", "map_key_mixed_numbers_uint_key_optindex_value"],
  ["optionals", "optionals", "map_key_mixed_numbers_int_key_optindex_value"],
  ["optionals", "optionals", "optional_eq_none_none"],
  ["optionals", "optionals", "optional_eq_none_int"],
  ["optionals", "optionals", "optional_eq_int_none"],
  ["optionals", "optionals", "optional_eq_int_int"],
  ["optionals", "optionals", "optional_ne_none_none"],
  ["optionals", "optionals", "optional_ne_none_int"],
  ["optionals", "optionals", "optional_ne_int_none"],
  ["optionals", "optionals", "optional_ne_int_int"],
  ["optionals", "optionals", "map_optional_has"],
  ["optionals", "optionals", "map_optional_select_has"],
  ["optionals", "optionals", "map_optional_entry_has"],
]);

describe("Conformance Tests", () => {
  const typeRegistry = getTestRegistry();
  for (const file of files) {
    testSimpleTestFile(file, typeRegistry, failures);
  }
});
