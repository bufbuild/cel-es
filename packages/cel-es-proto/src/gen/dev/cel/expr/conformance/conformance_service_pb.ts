// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.2.1 with parameter "target=ts,import_extension=none"
// @generated from file dev/cel/expr/conformance/conformance_service.proto (package dev.cel.expr.conformance, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { ParsedExpr } from "../syntax_pb";
import { Status } from "../../../../google/rpc/status_pb";
import { CheckedExpr, Decl } from "../checked_pb";
import { ExprValue } from "../eval_pb";

/**
 * Request message for the Parse method.
 *
 * @generated from message dev.cel.expr.conformance.ParseRequest
 */
export class ParseRequest extends Message<ParseRequest> {
  /**
   * Required. Source text in CEL syntax.
   *
   * @generated from field: string cel_source = 1;
   */
  celSource = "";

  /**
   * Tag for version of CEL syntax, for future use.
   *
   * @generated from field: string syntax_version = 2;
   */
  syntaxVersion = "";

  /**
   * File or resource for source text, used in [SourceInfo][google.api.SourceInfo].
   *
   * @generated from field: string source_location = 3;
   */
  sourceLocation = "";

  /**
   * Prevent macro expansion.  See "Macros" in Language Defiinition.
   *
   * @generated from field: bool disable_macros = 4;
   */
  disableMacros = false;

  constructor(data?: PartialMessage<ParseRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dev.cel.expr.conformance.ParseRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cel_source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "syntax_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "source_location", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "disable_macros", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ParseRequest {
    return new ParseRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ParseRequest {
    return new ParseRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ParseRequest {
    return new ParseRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ParseRequest | PlainMessage<ParseRequest> | undefined, b: ParseRequest | PlainMessage<ParseRequest> | undefined): boolean {
    return proto3.util.equals(ParseRequest, a, b);
  }
}

/**
 * Response message for the Parse method.
 *
 * @generated from message dev.cel.expr.conformance.ParseResponse
 */
export class ParseResponse extends Message<ParseResponse> {
  /**
   * The parsed representation, or unset if parsing failed.
   *
   * @generated from field: dev.cel.expr.ParsedExpr parsed_expr = 1;
   */
  parsedExpr?: ParsedExpr;

  /**
   * Any number of issues with [StatusDetails][] as the details.
   *
   * @generated from field: repeated google.rpc.Status issues = 2;
   */
  issues: Status[] = [];

  constructor(data?: PartialMessage<ParseResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dev.cel.expr.conformance.ParseResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parsed_expr", kind: "message", T: ParsedExpr },
    { no: 2, name: "issues", kind: "message", T: Status, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ParseResponse {
    return new ParseResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ParseResponse {
    return new ParseResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ParseResponse {
    return new ParseResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ParseResponse | PlainMessage<ParseResponse> | undefined, b: ParseResponse | PlainMessage<ParseResponse> | undefined): boolean {
    return proto3.util.equals(ParseResponse, a, b);
  }
}

/**
 * Request message for the Check method.
 *
 * @generated from message dev.cel.expr.conformance.CheckRequest
 */
export class CheckRequest extends Message<CheckRequest> {
  /**
   * Required. The parsed representation of the CEL program.
   *
   * @generated from field: dev.cel.expr.ParsedExpr parsed_expr = 1;
   */
  parsedExpr?: ParsedExpr;

  /**
   * Declarations of types for external variables and functions.
   * Required if program uses external variables or functions
   * not in the default environment.
   *
   * @generated from field: repeated dev.cel.expr.Decl type_env = 2;
   */
  typeEnv: Decl[] = [];

  /**
   * The protocol buffer context.  See "Name Resolution" in the
   * Language Definition.
   *
   * @generated from field: string container = 3;
   */
  container = "";

  /**
   * If true, use only the declarations in [type_env][google.api.expr.conformance.v1alpha1.CheckRequest.type_env].  If false (default),
   * add declarations for the standard definitions to the type environment.  See
   * "Standard Definitions" in the Language Definition.
   *
   * @generated from field: bool no_std_env = 4;
   */
  noStdEnv = false;

  constructor(data?: PartialMessage<CheckRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dev.cel.expr.conformance.CheckRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parsed_expr", kind: "message", T: ParsedExpr },
    { no: 2, name: "type_env", kind: "message", T: Decl, repeated: true },
    { no: 3, name: "container", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "no_std_env", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckRequest {
    return new CheckRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckRequest {
    return new CheckRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckRequest {
    return new CheckRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CheckRequest | PlainMessage<CheckRequest> | undefined, b: CheckRequest | PlainMessage<CheckRequest> | undefined): boolean {
    return proto3.util.equals(CheckRequest, a, b);
  }
}

/**
 * Response message for the Check method.
 *
 * @generated from message dev.cel.expr.conformance.CheckResponse
 */
export class CheckResponse extends Message<CheckResponse> {
  /**
   * The annotated representation, or unset if checking failed.
   *
   * @generated from field: dev.cel.expr.CheckedExpr checked_expr = 1;
   */
  checkedExpr?: CheckedExpr;

  /**
   * Any number of issues with [StatusDetails][] as the details.
   *
   * @generated from field: repeated google.rpc.Status issues = 2;
   */
  issues: Status[] = [];

  constructor(data?: PartialMessage<CheckResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dev.cel.expr.conformance.CheckResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "checked_expr", kind: "message", T: CheckedExpr },
    { no: 2, name: "issues", kind: "message", T: Status, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckResponse {
    return new CheckResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckResponse {
    return new CheckResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckResponse {
    return new CheckResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CheckResponse | PlainMessage<CheckResponse> | undefined, b: CheckResponse | PlainMessage<CheckResponse> | undefined): boolean {
    return proto3.util.equals(CheckResponse, a, b);
  }
}

/**
 * Request message for the Eval method.
 *
 * @generated from message dev.cel.expr.conformance.EvalRequest
 */
export class EvalRequest extends Message<EvalRequest> {
  /**
   * Required. Either the parsed or annotated representation of the CEL program.
   *
   * @generated from oneof dev.cel.expr.conformance.EvalRequest.expr_kind
   */
  exprKind: {
    /**
     * Evaluate based on the parsed representation.
     *
     * @generated from field: dev.cel.expr.ParsedExpr parsed_expr = 1;
     */
    value: ParsedExpr;
    case: "parsedExpr";
  } | {
    /**
     * Evaluate based on the checked representation.
     *
     * @generated from field: dev.cel.expr.CheckedExpr checked_expr = 2;
     */
    value: CheckedExpr;
    case: "checkedExpr";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Bindings for the external variables.  The types SHOULD be compatible
   * with the type environment in [CheckRequest][google.api.expr.conformance.v1alpha1.CheckRequest], if checked.
   *
   * @generated from field: map<string, dev.cel.expr.ExprValue> bindings = 3;
   */
  bindings: { [key: string]: ExprValue } = {};

  /**
   * SHOULD be the same container as used in [CheckRequest][google.api.expr.conformance.v1alpha1.CheckRequest], if checked.
   *
   * @generated from field: string container = 4;
   */
  container = "";

  constructor(data?: PartialMessage<EvalRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dev.cel.expr.conformance.EvalRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parsed_expr", kind: "message", T: ParsedExpr, oneof: "expr_kind" },
    { no: 2, name: "checked_expr", kind: "message", T: CheckedExpr, oneof: "expr_kind" },
    { no: 3, name: "bindings", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: ExprValue} },
    { no: 4, name: "container", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EvalRequest {
    return new EvalRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EvalRequest {
    return new EvalRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EvalRequest {
    return new EvalRequest().fromJsonString(jsonString, options);
  }

  static equals(a: EvalRequest | PlainMessage<EvalRequest> | undefined, b: EvalRequest | PlainMessage<EvalRequest> | undefined): boolean {
    return proto3.util.equals(EvalRequest, a, b);
  }
}

/**
 * Response message for the Eval method.
 *
 * @generated from message dev.cel.expr.conformance.EvalResponse
 */
export class EvalResponse extends Message<EvalResponse> {
  /**
   * The execution result, or unset if execution couldn't start.
   *
   * @generated from field: dev.cel.expr.ExprValue result = 1;
   */
  result?: ExprValue;

  /**
   * Any number of issues with [StatusDetails][] as the details.
   * Note that CEL execution errors are reified into [ExprValue][].
   * Nevertheless, we'll allow out-of-band issues to be raised,
   * which also makes the replies more regular.
   *
   * @generated from field: repeated google.rpc.Status issues = 2;
   */
  issues: Status[] = [];

  constructor(data?: PartialMessage<EvalResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dev.cel.expr.conformance.EvalResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "message", T: ExprValue },
    { no: 2, name: "issues", kind: "message", T: Status, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EvalResponse {
    return new EvalResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EvalResponse {
    return new EvalResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EvalResponse {
    return new EvalResponse().fromJsonString(jsonString, options);
  }

  static equals(a: EvalResponse | PlainMessage<EvalResponse> | undefined, b: EvalResponse | PlainMessage<EvalResponse> | undefined): boolean {
    return proto3.util.equals(EvalResponse, a, b);
  }
}

/**
 * A specific position in source.
 *
 * @generated from message dev.cel.expr.conformance.SourcePosition
 */
export class SourcePosition extends Message<SourcePosition> {
  /**
   * The source location name (e.g. file name).
   *
   * @generated from field: string location = 1;
   */
  location = "";

  /**
   * The UTF-8 code unit offset.
   *
   * @generated from field: int32 offset = 2;
   */
  offset = 0;

  /**
   * The 1-based index of the starting line in the source text
   * where the issue occurs, or 0 if unknown.
   *
   * @generated from field: int32 line = 3;
   */
  line = 0;

  /**
   * The 0-based index of the starting position within the line of source text
   * where the issue occurs.  Only meaningful if line is nonzero.
   *
   * @generated from field: int32 column = 4;
   */
  column = 0;

  constructor(data?: PartialMessage<SourcePosition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dev.cel.expr.conformance.SourcePosition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "location", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "offset", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "line", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "column", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SourcePosition {
    return new SourcePosition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SourcePosition {
    return new SourcePosition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SourcePosition {
    return new SourcePosition().fromJsonString(jsonString, options);
  }

  static equals(a: SourcePosition | PlainMessage<SourcePosition> | undefined, b: SourcePosition | PlainMessage<SourcePosition> | undefined): boolean {
    return proto3.util.equals(SourcePosition, a, b);
  }
}

/**
 * Warnings or errors in service execution are represented by
 * [google.rpc.Status][google.rpc.Status] messages, with the following message
 * in the details field.
 *
 * @generated from message dev.cel.expr.conformance.IssueDetails
 */
export class IssueDetails extends Message<IssueDetails> {
  /**
   * The severity of the issue.
   *
   * @generated from field: dev.cel.expr.conformance.IssueDetails.Severity severity = 1;
   */
  severity = IssueDetails_Severity.SEVERITY_UNSPECIFIED;

  /**
   * Position in the source, if known.
   *
   * @generated from field: dev.cel.expr.conformance.SourcePosition position = 2;
   */
  position?: SourcePosition;

  /**
   * Expression ID from [Expr][], 0 if unknown.
   *
   * @generated from field: int64 id = 3;
   */
  id = protoInt64.zero;

  constructor(data?: PartialMessage<IssueDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "dev.cel.expr.conformance.IssueDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "severity", kind: "enum", T: proto3.getEnumType(IssueDetails_Severity) },
    { no: 2, name: "position", kind: "message", T: SourcePosition },
    { no: 3, name: "id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IssueDetails {
    return new IssueDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IssueDetails {
    return new IssueDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IssueDetails {
    return new IssueDetails().fromJsonString(jsonString, options);
  }

  static equals(a: IssueDetails | PlainMessage<IssueDetails> | undefined, b: IssueDetails | PlainMessage<IssueDetails> | undefined): boolean {
    return proto3.util.equals(IssueDetails, a, b);
  }
}

/**
 * Severities of issues.
 *
 * @generated from enum dev.cel.expr.conformance.IssueDetails.Severity
 */
export enum IssueDetails_Severity {
  /**
   * An unspecified severity.
   *
   * @generated from enum value: SEVERITY_UNSPECIFIED = 0;
   */
  SEVERITY_UNSPECIFIED = 0,

  /**
   * Deprecation issue for statements and method that may no longer be
   * supported or maintained.
   *
   * @generated from enum value: DEPRECATION = 1;
   */
  DEPRECATION = 1,

  /**
   * Warnings such as: unused variables.
   *
   * @generated from enum value: WARNING = 2;
   */
  WARNING = 2,

  /**
   * Errors such as: unmatched curly braces or variable redefinition.
   *
   * @generated from enum value: ERROR = 3;
   */
  ERROR = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(IssueDetails_Severity)
proto3.util.setEnumType(IssueDetails_Severity, "dev.cel.expr.conformance.IssueDetails.Severity", [
  { no: 0, name: "SEVERITY_UNSPECIFIED" },
  { no: 1, name: "DEPRECATION" },
  { no: 2, name: "WARNING" },
  { no: 3, name: "ERROR" },
]);

